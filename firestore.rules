/**
 * This ruleset enforces a strict user-ownership model for the EduBot Central application.
 *
 * Core Philosophy:
 * The security model is built on the principle of path-based ownership. All user-specific
 * data is located under a path that includes the user's unique ID (UID), making it simple
 * and performant to grant access only to the authenticated owner of that data. The default
 * posture is deny-all, ensuring that no data is accessible unless explicitly allowed.
 *
 * Data Structure:
 * All user data is organized under the top-level `/users` collection. Each user has a single
 * document, where the document ID is the same as their Firebase Authentication UID.
 *   - /users/{userId} -> User profile document
 *
 * Key Security Decisions:
 * - User Isolation: A user can only read, create, update, or delete their own user document.
 *   They cannot access or even know about the existence of other users' documents.
 * - User Listing Disabled: To protect user privacy and prevent data scraping, it is
 *   impossible to list all documents in the `/users` collection.
 * - Relational Integrity: On creation, the user document must contain an `id` field that
 *   matches the user's UID in the path, ensuring data consistency. This `id` field is
 *   immutable and cannot be changed on update.
 *
 * Denormalization for Authorization:
 * This ruleset relies on path-based authorization (`/users/{userId}`), which is a form of
 * denormalization. The user's UID, which is the key piece of information for authorization,
 * is part of the document path itself. This avoids the need for slow and costly `get()`
 * calls to other documents to verify ownership.
 *
 * Structural Segregation:
 * The structure segregates each user's private data into their own document path. This
 * ensures that security rules are simple and that queries for a user's own data cannot
 * accidentally leak data belonging to another user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reusability.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the requested userId.
     * This is the core of our ownership-based security model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document already exists and if the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the internal 'id' field of a new user document matches
     * the document's path ID (the user's UID). This enforces relational integrity.
     */
    function hasValidUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces that critical, identifying fields are immutable.
     * The internal 'id' must never change after creation.
     */
    function hasImmutableDataOnUpdate() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * @description Rules for a user's own profile document. Access is strictly limited
     *              to the document owner.
     * @path /users/{userId}
     * @allow A signed-in user (auth.uid='user_abc') can `get` or `create` their own
     *        document at `/users/user_abc`.
     * @deny A signed-in user (auth.uid='user_abc') cannot `get` another user's document
     *       at `/users/user_xyz`. Listing the entire `/users` collection is also denied.
     * @principle Restricts access to a user's own data tree (Path-based Ownership).
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // CRITICAL: Prevents enumerating all users in the app.
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasImmutableDataOnUpdate();
      allow delete: if isExistingOwner(userId);
    }
  }
}