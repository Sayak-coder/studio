/**
 * This ruleset enforces a strict user-ownership and role-based model.
 *
 * Core Philosophy:
 * The default posture is deny-all. Access is granted explicitly.
 * - User Profiles (/users): Only the owner can read/write their own profile.
 * - User Listing (/users): Only users with an 'admin' custom claim can list all users.
 * - Content (/content): Any authenticated user can create/read. Only the author can update/delete.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reusability.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the authenticated user has an 'admin' custom claim.
     * This is the preferred method for role-based access control as it's fast and secure.
     */
    function isAdminClaim() {
      return isSignedIn() && request.auth.token.admin == true;
    }
    
    /**
     * Checks if the currently authenticated user has a specific role stored in their user document.
     * This is a fallback and can be subject to race conditions on initial user creation.
     */
    function isRole(role) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    // Rules for user profiles.
    match /users/{userId} {
      // An admin can read any user profile. An owner can read their own.
      allow get: if isAdminClaim() || isOwner(userId);
      
      // Allow a user to update or delete their own profile.
      allow update, delete: if isOwner(userId);
      
      // Allow any authenticated user to create their own profile, ensuring the ID matches.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      
      // Allow users with the 'admin' custom claim to list all users.
      allow list: if isAdminClaim();
    }

    // Rules for academic content.
    match /content/{contentId} {
      /**
       * @description Any authenticated user can read any piece of content.
       */
      allow get, list: if isSignedIn();

      /**
       * @description Any authenticated user can create a new piece of content,
       *              as long as they correctly set themselves as the author.
       */
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;

      /**
       * @description Only the original author of the content can update it.
       *              The authorId and createdAt fields are immutable.
       */
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid
                    && request.resource.data.authorId == resource.data.authorId
                    && request.resource.data.createdAt == resource.data.createdAt;
      
      /**
       * @description Only the original author of the content can delete it.
       */
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }
  }
}

service firebase.storage {
  match /b/{bucket}/o {
    // Allow reads by anyone (e.g., for public images or files).
    // In a real app, you'd likely restrict this further.
    allow read: if true;

    // Allow writes only for authenticated users.
    // The file path must match the user's UID.
    // This rule ensures users can only upload files to their own "folder".
    // We also limit the file size to 5MB.
    match /content/{userId}/{allPaths=**} {
      allow write: if request.auth != null 
                   && request.auth.uid == userId
                   && request.resource.size < 5 * 1024 * 1024
                   && request.resource.contentType.matches('image/.*|application/pdf');
    }
  }
}
